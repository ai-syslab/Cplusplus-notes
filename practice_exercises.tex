\documentclass{article}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{hyperref}

\title{Coding Problems}
\author{}
\date{}

\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{cppstyle}{
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegray},
  keywordstyle=\color{blue},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{red},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=none,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  language=C++
}

\begin{document}

\maketitle

\section{FizzBuzz Problem}

\textbf{Problem Statement:}

Write a function in C++ that prints the numbers from 1 to \texttt{n}. But for multiples of three, print \texttt{"Fizz"} instead of the number, and for the multiples of five, print \texttt{"Buzz"}. For numbers which are multiples of both three and five, print \texttt{"FizzBuzz"}.

\textbf{Function Signature:}

\begin{lstlisting}[style=cppstyle]
void fizzbuzz(int n);
\end{lstlisting}

\textbf{Example Test Case:}

The following \texttt{main()} function runs a test with \texttt{n = 15} and should produce output matching the expected result described below.

\begin{lstlisting}[style=cppstyle]
#include <iostream>
using namespace std;

void fizzbuzz(int n) {
    // TODO: Implement this function
}

int main() {
    fizzbuzz(15);
    return 0;
}
\end{lstlisting}

\textbf{Expected Output:}
\begin{verbatim}
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Working with Vectors: Student Scores Analyzer}

\textbf{Problem Statement:}

Write a C++ program to read and analyze a list of student test scores. Your task is to implement a function named \texttt{analyzeScores()} that performs the following steps using a \texttt{std::vector<int>}:

\begin{enumerate}
  \item Read a list of integer scores from the user until \texttt{-1} is entered (which should not be included in the list).
  \item Display the total number of scores entered.
  \item Compute and print the average score (as a \texttt{double}, rounded automatically by standard output).
  \item Remove all scores from the vector that are strictly less than the average.
  \item Print the updated list of scores, one per line.
\end{enumerate}

\textbf{Function Signature:}

\begin{lstlisting}[style=cppstyle]
void analyzeScores();
\end{lstlisting}

\textbf{Test Case:}

Use the following \texttt{main()} function to test your implementation.

\begin{lstlisting}[style=cppstyle]
#include <iostream>
using namespace std;

int main() {
    analyzeScores();
    return 0;
}
\end{lstlisting}

\textbf{Example Input (typed by user):}
\begin{verbatim}
80
90
70
60
100
-1
\end{verbatim}

\textbf{Expected Output:}
\begin{verbatim}
Total scores entered: 5
Average score: 80
Scores above or equal to average:
80
90
100
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Class Design: BankAccount}

\textbf{Problem Statement:}

Design and implement a C++ class named \texttt{BankAccount} to model a simple bank account. The class should meet the following requirements:

\begin{itemize}
  \item The class must have two private data members:
    \begin{itemize}
      \item \texttt{name} (a \texttt{string}): the name of the account holder
      \item \texttt{balance} (a \texttt{double}): the account balance
    \end{itemize}
  \item Provide a constructor that takes the account holder's name and an initial balance as parameters.
  \item Provide getter methods for both the name and the balance.
  \item Provide a setter method to update the name.
  \item Provide two public methods:
    \begin{itemize}
      \item \texttt{deposit(double amount)}: adds the amount to the balance
      \item \texttt{withdraw(double amount)}: subtracts the amount from the balance, but only if sufficient funds are available
    \end{itemize}
\end{itemize}

\textbf{Function Signatures:}

\begin{lstlisting}[style=cppstyle]
class BankAccount {
    // Implement this class
};
\end{lstlisting}

\textbf{Test Case:}

Use the following \texttt{main()} function to test your implementation.

\begin{lstlisting}[style=cppstyle]
#include <iostream>
using namespace std;

int main() {
    BankAccount acc("Alice", 1000.0);
    
    cout << "Name: " << acc.getName() << endl;
    cout << "Initial Balance: " << acc.getBalance() << endl;
    
    acc.deposit(500.0);
    cout << "After deposit: " << acc.getBalance() << endl;
    
    acc.withdraw(200.0);
    cout << "After withdrawal: " << acc.getBalance() << endl;

    acc.withdraw(2000.0);  // Should not allow, balance unchanged
    cout << "After failed withdrawal: " << acc.getBalance() << endl;
    
    acc.setName("Bob");
    cout << "Updated Name: " << acc.getName() << endl;

    return 0;
}
\end{lstlisting}

\textbf{Expected Output:}

\begin{verbatim}
Name: Alice
Initial Balance: 1000
After deposit: 1500
After withdrawal: 1300
After failed withdrawal: 1300
Updated Name: Bob
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Dynamic Memory and Rule of Three}
Write the implementation for the following C++ class that models a Game Inventory system.
\begin{lstlisting}[style=cppstyle]
	#ifndef INVENTORY_H
	#define INVENTORY_H
	
	#include <string>
	
	class Item {
	public:
		Item(const std::string& name, int quantity);
		std::string getName() const;
		int getQuantity() const;
	
	private:
		std::string name; 
		int quantity;
	};
	
	class Inventory {
	public:
		Inventory();
		Inventory(const Inventory& other);
		Inventory& operator=(const Inventory& other);
		~Inventory();
	
		void addItem(const std::string& name, int quantity);
		void removeItem(const std::string& name);
		void printInventory() const;
	
	private:
		Item** items;   // dynamic array of pointers to Items
		int size;       // current number of items
		int capacity;   // allocated capacity
	
		void resize();
		void deepCopy(const Inventory& other);
		void freeMemory();
	};
	
	#endif // INVENTORY_H

// main.cpp
// Test driver for Inventory/Item exercise.
// Assumes printInventory() output format described above.

// Expected output is at the bottom of this file in a block comment.

#include <iostream>
#include "Inventory.h"

int main() {
    // [1] Default construct: should be empty
    Inventory inv;
    std::cout << "[1] Newly created inventory\n";
    inv.printInventory();  // Inventory: (empty)

    // [2] Add three distinct items
    inv.addItem("Apples", 10);
    inv.addItem("Bananas", 5);
    inv.addItem("Carrots", 12);

    std::cout << "\n[2] After adding 3 items\n";
    inv.printInventory();
    // Inventory:
    // - Apples (10)
    // - Bananas (5)
    // - Carrots (12)

    // [3] Remove one existing item
    inv.removeItem("Bananas");

    std::cout << "\n[3] After removing Bananas\n";
    inv.printInventory();
    // Inventory:
    // - Apples (10)
    // - Carrots (12)

    // [4] Test copy constructor (deep copy)
    Inventory copy = inv;
    std::cout << "\n[4] Copy-constructed inventory (should match [3])\n";
    copy.printInventory();
    // Inventory:
    // - Apples (10)
    // - Carrots (12)

    // Mutate original; copy should remain unchanged if deep copy is correct
    inv.removeItem("Apples");

    std::cout << "\n[5] Original after removing Apples\n";
    inv.printInventory();
    // Inventory:
    // - Carrots (12)

    std::cout << "\n[6] Copy remains unchanged\n";
    copy.printInventory();
    // Inventory:
    // - Apples (10)
    // - Carrots (12)

    // [5] Test copy assignment (deep copy)
    Inventory assigned;
    assigned = inv;  // copy assignment from current 'inv'

    std::cout << "\n[7] Assigned-from-original inventory (should match [5])\n";
    assigned.printInventory();
    // Inventory:
    // - Carrots (12)

    // Final destructor checks happen on scope exit (inv, copy, assigned)

    return 0;
}

/*
===========================
EXPECTED PROGRAM OUTPUT
===========================

[1] Newly created inventory
Inventory: (empty)

[2] After adding 3 items
Inventory:
- Apples (10)
- Bananas (5)
- Carrots (12)

[3] After removing Bananas
Inventory:
- Apples (10)
- Carrots (12)

[4] Copy-constructed inventory (should match [3])
Inventory:
- Apples (10)
- Carrots (12)

[5] Original after removing Apples
Inventory:
- Carrots (12)

[6] Copy remains unchanged
Inventory:
- Apples (10)
- Carrots (12)

[7] Assigned-from-original inventory (should match [5])
Inventory:
- Carrots (12)

*/

\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Merging Two Singly Linked Lists}

You are given a basic implementation of a singly linked list storing \texttt{int} values. Your task is to write a member function \texttt{mergeWith} that merges the current list with another sorted linked list, resulting in a single sorted linked list. Both lists are sorted in non-decreasing order.

\subsection*{Requirements}
\begin{itemize}
  \item Do not create new nodes.
  \item Reuse existing nodes and rearrange their \texttt{next} pointers.
  \item After merging, the current list (\texttt{*this}) should point to the merged result.
\end{itemize}

\subsection*{Given Code}

\begin{lstlisting}[style=cppstyle]
#include <iostream>

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;

public:
    LinkedList() : head(nullptr) {}

    void insertAtEnd(int val) {
        Node* newNode = new Node(val);
        if (!head) {
            head = newNode;
            return;
        }
        Node* temp = head;
        while (temp->next)
            temp = temp->next;
        temp->next = newNode;
    }

    void print() const {
        Node* temp = head;
        while (temp) {
            std::cout << temp->data << " -> ";
            temp = temp->next;
        }
        std::cout << "NULL\n";
    }

    // TODO: Implement this
    void mergeWith(LinkedList& other);
};
\end{lstlisting}

\subsection*{Your Task}

Complete the implementation of the \texttt{mergeWith} function that merges two sorted lists.

\subsection*{Expected Behavior (Test)}

\begin{lstlisting}[style=cppstyle]
int main() {
    LinkedList list1;
    list1.insertAtEnd(1);
    list1.insertAtEnd(3);
    list1.insertAtEnd(5);

    LinkedList list2;
    list2.insertAtEnd(2);
    list2.insertAtEnd(4);
    list2.insertAtEnd(6);

    list1.mergeWith(list2);
    list1.print(); // Expected: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> NULL

    return 0;
}
\end{lstlisting}

\end{document}